import type { ConversationReport } from "shared";
import { pdf, measureText } from "tinypdf";

const PAGE_WIDTH = 595.28;
const PAGE_HEIGHT = 841.89;
const MARGIN = 48;
const LINE_HEIGHT = 14;
const FOOTER_GAP = 60;

type Command =
	| {
			type: "text";
			x: number;
			y: number;
			size: number;
			text: string;
			options?: Record<string, unknown>;
	  }
	| { type: "bullet"; x: number; y: number; size: number; text: string }
	| {
			type: "line";
			x1: number;
			y1: number;
			x2: number;
			y2: number;
			color: string;
			width?: number;
	  }
	| { type: "rect"; x: number; y: number; w: number; h: number; fill?: string }
	| { type: "footer" };

export async function generatePdfFromReport(
	report: ConversationReport
): Promise<Uint8Array> {
	const doc = pdf();
	let commands: Command[] = [];
	let cursorY = MARGIN;

	function wrapText(text: string, maxWidth: number, size: number): string[] {
		const words = text.split(/\s+/);
		const lines: string[] = [];
		let currentLine = "";
		for (const word of words) {
			const testLine = currentLine ? `${currentLine} ${word}` : word;
			if (measureText(testLine, size) <= maxWidth) currentLine = testLine;
			else {
				lines.push(currentLine);
				currentLine = word;
			}
		}
		if (currentLine) lines.push(currentLine);
		return lines;
	}

	function startPage() {
		commands = [];

		commands.push({
			type: "rect",
			x: 0,
			y: 0,
			w: PAGE_WIDTH,
			h: 65,
			fill: "#f9fafb",
		});

		commands.push({
			type: "text",
			x: MARGIN,
			y: 20,
			size: 14,
			text: report.reportTitle.toUpperCase(),
			options: { color: "#111827", bold: true },
		});

		commands.push({
			type: "text",
			x: MARGIN,
			y: 38,
			size: 8,
			text: `Generated by Marmalade AI - ${new Date().toLocaleDateString()}`,
			options: { color: "#6b7280" },
		});

		commands.push({
			type: "line",
			x1: MARGIN,
			y1: 65,
			x2: PAGE_WIDTH - MARGIN,
			y2: 65,
			color: "#e5e7eb",
			width: 0.5,
		});

		cursorY = 90;
	}

	function flushPage() {
		commands.push({ type: "footer" });
		const pageCommands = [...commands];
		doc.page((p) => {
			for (const cmd of pageCommands) {
				switch (cmd.type) {
					case "text":
						p.text(
							cmd.text,
							cmd.x,
							PAGE_HEIGHT - cmd.y,
							cmd.size,
							cmd.options || {}
						);
						break;
					case "bullet":
						p.text("-", cmd.x - 10, PAGE_HEIGHT - cmd.y, cmd.size, {
							color: "#71717a",
						});
						p.text(cmd.text, cmd.x, PAGE_HEIGHT - cmd.y, cmd.size);
						break;
					case "line":
						p.line(
							cmd.x1,
							PAGE_HEIGHT - cmd.y1,
							cmd.x2,
							PAGE_HEIGHT - cmd.y2,
							cmd.color,
							cmd.width
						);
						break;
					case "rect":
						p.rect(
							cmd.x,
							PAGE_HEIGHT - (cmd.y + cmd.h),
							cmd.w,
							cmd.h,
							cmd.fill ?? ""
						);
						break;
					case "footer":
						const footerY = MARGIN;
						p.line(
							MARGIN,
							PAGE_HEIGHT - footerY - 20,
							PAGE_WIDTH - MARGIN,
							PAGE_HEIGHT - footerY - 20,
							"#e4e4e7",
							0.5
						);
						p.text(
							"Marmalade - Personal AI Thought Partner",
							MARGIN,
							PAGE_HEIGHT - footerY - 10,
							7,
							{ color: "#9ca3af" }
						);
						p.text(
							"This report is AI-generated and for informational purposes only. Not a substitute for professional advice.",
							MARGIN,
							PAGE_HEIGHT - footerY - 20,
							7,
							{ color: "#9ca3af", width: PAGE_WIDTH - MARGIN * 2 }
						);
						break;
				}
			}
		});
		commands = [];
		cursorY = MARGIN;
	}

	function ensureSpace(needed = 0) {
		if (cursorY + needed + FOOTER_GAP >= PAGE_HEIGHT - MARGIN) {
			flushPage();
			startPage();
		}
	}

	function addSectionHeading(heading: string) {
		ensureSpace(30);
		cursorY += 17;
		commands.push({
			type: "text",
			x: MARGIN,
			y: cursorY,
			size: 10,
			text: heading.toUpperCase(),
			options: { color: "#111827", bold: true },
		});
		cursorY += 16;
	}

	function addParagraph(text: string, size = 9, color = "#3f3f46") {
		const lines = wrapText(text, PAGE_WIDTH - MARGIN * 2, size);
		for (const line of lines) {
			ensureSpace(LINE_HEIGHT);
			commands.push({
				type: "text",
				x: MARGIN,
				y: cursorY,
				size,
				text: line,
				options: { color },
			});
			cursorY += LINE_HEIGHT;
		}
		cursorY += 4;
	}

	function addBulletedList(items: string[]) {
		for (const item of items) {
			const lines = wrapText(item, PAGE_WIDTH - MARGIN * 2 - 20, 9);
			for (const [i, line] of lines.entries()) {
				ensureSpace(LINE_HEIGHT);
				if (i === 0)
					commands.push({
						type: "bullet",
						x: MARGIN + 12,
						y: cursorY,
						size: 9,
						text: line,
					});
				else
					commands.push({
						type: "text",
						x: MARGIN + 12,
						y: cursorY,
						size: 9,
						text: line,
					});
				cursorY += LINE_HEIGHT;
			}
			cursorY += 2;
		}
	}

	function addQuote(quote: string) {
		const lines = wrapText(quote, PAGE_WIDTH - MARGIN * 2 - 32, 9);
		const boxHeight = lines.length * LINE_HEIGHT + 16;
		ensureSpace(boxHeight + 8);
		commands.push({
			type: "rect",
			x: MARGIN,
			y: cursorY,
			w: PAGE_WIDTH - MARGIN * 2,
			h: boxHeight,
			fill: "#f8fafc",
		});
		cursorY += 10;
		for (const line of lines) {
			commands.push({
				type: "text",
				x: MARGIN + 16,
				y: cursorY,
				size: 9,
				text: line,
				options: { color: "#0369a1" },
			});
			cursorY += LINE_HEIGHT;
		}
		cursorY += 10;
	}

	startPage();

	if (report.soapNote?.subjective?.summary) {
		addSectionHeading("Patient Subjective");
		addParagraph(report.soapNote.subjective.summary);
		report.soapNote.subjective.userQuotes?.forEach(addQuote);
	}

	if (report.soapNote?.assessment) {
		addSectionHeading("Clinical Assessment");
		addParagraph(report.soapNote.assessment.summaryOfThemesNoDiagnosis);
		report.soapNote.assessment.narrativeThemes?.forEach((t) => {
			addParagraph(`Theme: ${t.theme}`, 9, "#111827");
			if (t.evidence?.length) addBulletedList(t.evidence);
		});
	}

	if (report.clinicalMemo) {
		addSectionHeading("Clinical Continuity & Patterns");
		report.clinicalMemo.continuitySignals?.forEach((s) => {
			addParagraph(`${s.label}: ${s.description}`, 9, "#111827");
			if (s.evidence?.length) addBulletedList(s.evidence);
		});
		const risk = report.clinicalMemo.riskSummary;
		if (risk) {
			addParagraph(
				`Risk Level: ${risk.maxRiskLevelObserved}`,
				9,
				risk.maxRiskLevelObserved > 0 ? "#ef4444" : "#10b981"
			);
			addParagraph(risk.notes, 8);
		}
	}

	const questions =
		report.soapNote?.plan?.suggestedTherapyQuestions ||
		report.clinicalMemo?.suggestedTherapyQuestions;
	if (questions?.length) {
		addSectionHeading("Suggested Therapy Questions");
		addBulletedList(questions);
	}

	flushPage();
	return doc.build();
}
