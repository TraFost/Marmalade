%% Marmalade — Expanded Architecture Diagram
%% File: docs/architecture-expanded.mmd
%% Contains: Flowchart (system components) + Sequence (turn flow) + short annotations

%% Flowchart: high-level components + data flows
```mermaid
flowchart LR
  %% CLIENT
  subgraph CLIENT ["Client (Browser / App)"]
    direction TB
    Onboard[Onboarding UI<br/>(5 steps + V2 fields)]
    ChatUI[Chat UI / Voice Input]
    Onboard -->|POST /api/state-mapping/upsert| API_Upsert
    Onboard -->|GET /api/state-mapping/graph| API_Graph
    ChatUI -->|POST /v1/chat/completions| Hooks
    ChatUI -->|HTTP/WS message (optional)| API_Conversation
    Onboard -. hydrate (pristine only) .-> Onboard
  end

  %% SERVER ROUTES
  subgraph SERVER_ROUTES ["Server (Hono)"]
    direction LR
    API_Graph[GET /api/state-mapping/graph<br/>(state-mapping.route.ts)]
    API_Upsert[POST /api/state-mapping/upsert<br/>(state-mapping.route.ts)]
    Hooks[/POST /v1/chat/completions<br/>(hooks.route.ts)/]
    API_Conversation[POST /api/conversation (optional)]
    SSE[GET /api/messages/events<br/>(SSE stream)]
    Reports[POST /api/reports/session<br/>(reports.route.ts)]
  end

  %% SERVICES & AGENTS
  subgraph SERVICES ["Server services & agents"]
    direction TB
    StateService[StateMappingService<br/>(merges signals & anchors)]
    SessionService[SessionService<br/>(bootstrap from screenings -> graph)]
    ConvService[ConversationService<br/>(turn pipeline)]
    MiniBrain[MiniBrainClient<br/>(fast state-read + delta)]
    TurnCoord[Turn Coordinator<br/>(language-shaper, arbiter, monitor, memory-curator)]
    LangShaper[Language Shaper<br/>(pref-aware)]
    Arbiter[Intervention Arbiter<br/>(gating rules)]
    MemoryCurator[Memory Curator<br/>(update graph history & anchors)]
    Counselor[Counselor Brain Client<br/>(final response)]
    EmbeddingRepo[EmbeddingRepository (RAG)]
  end

  %% DATA PERSISTENCE
  subgraph DB ["DB / Storage (Postgres)"]
    direction TB
    ConvState[conversation_state table<br/>(preferences JSON)]
    Messages[messages table]
    MemoryDocs[memory docs / embeddings]
  end

  %% Flows
  API_Graph -->|fetch| StateService
  API_Upsert -->|validate & upsert| StateService
  StateService -->|persist| ConvState
  StateService -->|return| API_Graph

  Hooks -->|map externalSessionId → internal (externalSessionToInternal)| SessionService
  Hooks -->|prepareTurn: ensure session, persist message| ConvService
  API_Conversation --> ConvService
  ConvService -->|retrieve relevant docs| EmbeddingRepo
  ConvService -->|analyze turn| MiniBrain
  MiniBrain -->|stateRead, stateDelta| ConvService
  ConvService --> TurnCoord
  TurnCoord --> LangShaper
  TurnCoord --> Arbiter
  TurnCoord --> MemoryCurator
  TurnCoord -->|decision & language plan| ConvService
  ConvService -->|call| FirstResponse
  ConvService -->|call| Counselor
  %% Counselor is wrapped with timeout (withTimeout → EMERGENCY_PACKET fallback)
  Counselor -. withTimeout/EMERGENCY_PACKET .-> ConvService
  FirstResponse --> ConvService
  Counselor -->|reply| ConvService
  ConvService -->|emit events| EventBusNode
  EventBusNode -->|stream chunks| SSE
  EventBusNode -->|emit report-ready| Reports
  ConvService -->|persist updated graph/signals| StateService
  ConvService -->|persist message| Messages

  %% Notes
  classDef note fill:#f6f9ff,stroke:#c6d8ff;
  Note[(Note: State mapping stored in preferences JSON — no DB migrations required)]:::note
  RiskNote[(Risk mapping: 0–4 → normal / caution / high_caution / crisis)<br/>See `getSafetyMode()` in `server/src/services/conversation.service.ts`.]:::note
  RaceNote[(Streaming race: FirstResponse provides quick text; Counselor starts once emittedWordCount >= threshold)<br/>See `handleUserTurnModelStream()`]:::note

  %% File references (legend)
  subgraph REFS ["Key files / types"]
    direction LR
    T1[shared/src/types/state-graph.type.ts]
    R1[server/src/routes/state-mapping.route.ts]
    HR1[server/src/routes/hooks.route.ts]
    S1[server/src/services/state-mapping.service.ts]
    C1[server/src/services/conversation.service.ts]
    EB1[server/src/libs/events/event-bus.ts]
    SR1[server/src/libs/ai/session-report.client.ts]
    A1[server/src/libs/ai/agents/*]
    U1[client/src/features/welcome/pages/onboarding.page.tsx]
  end
```


%% Sequence: a single turn (message) + onboarding hydration
```mermaid
sequenceDiagram
  participant Client
  participant API as Server API
  participant State as StateMappingService
  participant Conv as ConversationService
  participant Mini as MiniBrain
  participant Coord as TurnCoordinator
  participant Lang as LanguageShaper
  participant Arb as InterventionArbiter
  participant Coun as Counselor
  participant DB as DB (conversation_state)
  participant Emb as EmbeddingRepository

  Note over Client,State: Onboarding (pristine) request to /graph hydrates form
  Client->>API: GET /api/state-mapping/graph
  API->>State: getGraph(userId)
  State-->>API: { graph, signals }
  API-->>Client: 200 OK (graph + signals)

  Note over Client,Conv: User sends message / voice input (via hooks)
  Client->>API: POST /v1/chat/completions {messages} (hooks.route.ts)
  API->>SessionService: map externalSessionId → internalSessionId (externalSessionToInternal)
  API->>Conv: prepareTurn (ensureSession, persist message) [hooks.route.ts -> MessageRepository]
  Conv->>DB: load conversation_state (preferences)
  DB-->>Conv: preferences { userStateGraph, stateMappingSignals }
  Conv->>Emb: findRelevant(userMessage)
  Conv->>Mini: analyzeTurn({userMessage, recentMessages, currentState})
  Mini-->>Conv: { stateRead, stateDelta, mood, riskLevel, suggestions }
  Conv->>Coord: coordinateTurn({userMessage, graph, stateRead, signals})
  Coord->>Lang: buildLanguageMirrorPlan(userText, {interactionPreference, willStatus})
  Coord->>Arb: decideIntervention({stateRead, delta, graph, signals})
  Coord-->>Conv: { languagePlan, decision, nextGraph }
  Conv->>First: call FirstResponse (server/src/libs/ai/first-response.client.ts)
  Conv->>Coun: generateReply({systemInstruction, preferences, context}) (server/src/libs/ai/counselor-brain.client.ts)
  Coun -. withTimeout / EMERGENCY_PACKET .-> Conv
  First-->>Conv: streaming quick text
  Coun-->>Conv: streaming substantive text
  Conv->>DB: persist assistant message & updated preferences (nextGraph, updated signals)
  Conv->>EventBusNode: emit stream chunks / report-ready
  EventBusNode-->>SSE: stream chunks (GET /api/messages/events)
  EventBusNode-->>Reports: report-ready (optional)
  Conv-->>Client: streaming reply / final reply
  Note over Conv,Summary: Optional: request SOAP report via report.service.ts, persist report (report.repository / memory_docs) and notify report-ready via EventBus
```


%% Component Detail: decision heuristics (short)
```mermaid
flowchart TB
  subgraph heur [Intervention Heuristics]
    flags[flags: agitationRising | cognitiveFragmentation | meaningMakingOnline]
    will[willStatus: collapsed | strained | stable]
    anchors[lifeAnchors present?]
    flags -->|if true| grounding[Grounding Eligible]
    will -->|collapsed/strained & low agency| grounding
    anchors -->|futureContinuityThreatened| anchoring
  end
```